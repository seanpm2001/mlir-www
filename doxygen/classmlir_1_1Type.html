<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::Type Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">17.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="classmlir_1_1Type.html">Type</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmlir_1_1Type-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::Type Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Instances of the <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> class are uniqued, have an immutable identifier and an optional mutable component.  
 <a href="classmlir_1_1Type.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="IR_2Types_8h_source.html">mlir/IR/Types.h</a>&quot;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for mlir::Type:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classmlir_1_1Type__inherit__graph.png" border="0" usemap="#amlir_1_1Type_inherit__map" alt="Inheritance graph"/></div>
<map name="amlir_1_1Type_inherit__map" id="amlir_1_1Type_inherit__map">
<area shape="rect" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone..." alt="" coords="5,202,92,229"/>
<area shape="rect" href="classmlir_1_1detail_1_1Interface.html" title=" " alt="" coords="155,5,322,76"/>
<area shape="rect" href="classmlir_1_1BaseMemRefType.html" title="This class provides a shared interface for ranked and unranked memref types." alt="" coords="152,101,325,127"/>
<area shape="rect" href="classmlir_1_1FloatType.html" title=" " alt="" coords="179,151,298,178"/>
<area shape="rect" href="classmlir_1_1TensorType.html" title="Tensor types represent multi&#45;dimensional arrays, and have two variants: RankedTensorType and Unranked..." alt="" coords="175,202,303,229"/>
<area shape="rect" href="classmlir_1_1pdl_1_1PDLType.html" title="This class represents the base class of all PDL types." alt="" coords="169,253,308,279"/>
<area shape="rect" href="classmlir_1_1quant_1_1QuantizedType.html" title="Base class for all quantized types known to this dialect." alt="" coords="140,303,337,330"/>
<area shape="rect" href="classmlir_1_1spirv_1_1SPIRVType.html" title=" " alt="" coords="157,354,320,381"/>
<area shape="rect" href="classmlir_1_1TypeInterface.html" title="This class represents the base of a type interface." alt="" coords="391,20,574,61"/>
<area shape="rect" href="classmlir_1_1spirv_1_1CompositeType.html" title=" " alt="" coords="385,329,580,355"/>
<area shape="rect" href="classmlir_1_1spirv_1_1ScalarType.html" title=" " alt="" coords="400,379,565,406"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acd35e3f5186bd1c0e4c4f53f69aad716"><td class="memTemplParams" colspan="2">template&lt;typename ConcreteType , typename BaseType , typename StorageType , template&lt; typename T &gt; class... Traits&gt; </td></tr>
<tr class="memitem:acd35e3f5186bd1c0e4c4f53f69aad716"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#acd35e3f5186bd1c0e4c4f53f69aad716">TypeBase</a> = <a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html">detail::StorageUserBase</a>&lt; ConcreteType, <a class="el" href="classBaseType.html">BaseType</a>, StorageType, <a class="el" href="structmlir_1_1detail_1_1TypeUniquer.html">detail::TypeUniquer</a>, Traits... &gt;</td></tr>
<tr class="memdesc:acd35e3f5186bd1c0e4c4f53f69aad716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for implementing types.  <a href="classmlir_1_1Type.html#acd35e3f5186bd1c0e4c4f53f69aad716">More...</a><br /></td></tr>
<tr class="separator:acd35e3f5186bd1c0e4c4f53f69aad716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89de246b01ef652963e1ddde953d62e7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a89de246b01ef652963e1ddde953d62e7">ImplType</a> = <a class="el" href="classmlir_1_1TypeStorage.html">TypeStorage</a></td></tr>
<tr class="separator:a89de246b01ef652963e1ddde953d62e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da492d52032c9c9d4fe2a1768437e13"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a0da492d52032c9c9d4fe2a1768437e13">AbstractTy</a> = <a class="el" href="classmlir_1_1AbstractType.html">AbstractType</a></td></tr>
<tr class="separator:a0da492d52032c9c9d4fe2a1768437e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a622149b48f6d7eaf0e42f8abea6ca65e"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a622149b48f6d7eaf0e42f8abea6ca65e">Type</a> ()=default</td></tr>
<tr class="separator:a622149b48f6d7eaf0e42f8abea6ca65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8871458ee7b2abdca3e94788ae3048"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#aaa8871458ee7b2abdca3e94788ae3048">Type</a> (const <a class="el" href="classmlir_1_1Type.html#a89de246b01ef652963e1ddde953d62e7">ImplType</a> *<a class="el" href="classmlir_1_1Type.html#a54af6c081e012a32bba9b650480c6c06">impl</a>)</td></tr>
<tr class="separator:aaa8871458ee7b2abdca3e94788ae3048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237023ae4dcab369d064457a10bcf518"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a237023ae4dcab369d064457a10bcf518">Type</a> (const <a class="el" href="classmlir_1_1Type.html">Type</a> &amp;other)=default</td></tr>
<tr class="separator:a237023ae4dcab369d064457a10bcf518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860e9e7612215565aadad622ccf4cbb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a860e9e7612215565aadad622ccf4cbb0">operator=</a> (const <a class="el" href="classmlir_1_1Type.html">Type</a> &amp;other)=default</td></tr>
<tr class="separator:a860e9e7612215565aadad622ccf4cbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53df1249058e8c2ec0fa70f172f0b59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ac53df1249058e8c2ec0fa70f172f0b59">operator==</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> other) const</td></tr>
<tr class="separator:ac53df1249058e8c2ec0fa70f172f0b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1be45203a0010965388d41e712dc268"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ad1be45203a0010965388d41e712dc268">operator!=</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> other) const</td></tr>
<tr class="separator:ad1be45203a0010965388d41e712dc268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb8b20e59002a0fedfcb93e314b416f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#afeb8b20e59002a0fedfcb93e314b416f">operator bool</a> () const</td></tr>
<tr class="separator:afeb8b20e59002a0fedfcb93e314b416f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac516f7c8eb957068555b5781d78f23af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ac516f7c8eb957068555b5781d78f23af">operator!</a> () const</td></tr>
<tr class="separator:ac516f7c8eb957068555b5781d78f23af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd295cf88ab7faa33601d3bbee5c4b8"><td class="memTemplParams" colspan="2">template&lt;typename... Tys&gt; </td></tr>
<tr class="memitem:adcd295cf88ab7faa33601d3bbee5c4b8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#adcd295cf88ab7faa33601d3bbee5c4b8">isa</a> () const</td></tr>
<tr class="separator:adcd295cf88ab7faa33601d3bbee5c4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a0015618ae48c270a23609298e6568"><td class="memTemplParams" colspan="2">template&lt;typename... Tys&gt; </td></tr>
<tr class="memitem:a46a0015618ae48c270a23609298e6568"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a46a0015618ae48c270a23609298e6568">isa_and_nonnull</a> () const</td></tr>
<tr class="separator:a46a0015618ae48c270a23609298e6568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8d33d03b9736dfcc3cc0e9351b1826"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a6b8d33d03b9736dfcc3cc0e9351b1826"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a6b8d33d03b9736dfcc3cc0e9351b1826">dyn_cast</a> () const</td></tr>
<tr class="separator:a6b8d33d03b9736dfcc3cc0e9351b1826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ca8bbee5e3e8a02e0df18897981edf"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a33ca8bbee5e3e8a02e0df18897981edf"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a33ca8bbee5e3e8a02e0df18897981edf">dyn_cast_or_null</a> () const</td></tr>
<tr class="separator:a33ca8bbee5e3e8a02e0df18897981edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9c3e06d3b23ad9457c13cb828a7c48"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a1a9c3e06d3b23ad9457c13cb828a7c48"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a1a9c3e06d3b23ad9457c13cb828a7c48">cast</a> () const</td></tr>
<tr class="separator:a1a9c3e06d3b23ad9457c13cb828a7c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf7dade447f73f5b04c46fcf616b68c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#accf7dade447f73f5b04c46fcf616b68c">getTypeID</a> ()</td></tr>
<tr class="memdesc:accf7dade447f73f5b04c46fcf616b68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a unique identifier for the concrete type.  <a href="classmlir_1_1Type.html#accf7dade447f73f5b04c46fcf616b68c">More...</a><br /></td></tr>
<tr class="separator:accf7dade447f73f5b04c46fcf616b68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3951cad794a5bc5ad086158c20f8e50e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a3951cad794a5bc5ad086158c20f8e50e">getContext</a> () const</td></tr>
<tr class="memdesc:a3951cad794a5bc5ad086158c20f8e50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a> in which this type was uniqued.  <a href="classmlir_1_1Type.html#a3951cad794a5bc5ad086158c20f8e50e">More...</a><br /></td></tr>
<tr class="separator:a3951cad794a5bc5ad086158c20f8e50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21810b671ec68509499ee2d4f10a8a6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Dialect.html">Dialect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a21810b671ec68509499ee2d4f10a8a6b">getDialect</a> () const</td></tr>
<tr class="memdesc:a21810b671ec68509499ee2d4f10a8a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dialect this type is registered to.  <a href="classmlir_1_1Type.html#a21810b671ec68509499ee2d4f10a8a6b">More...</a><br /></td></tr>
<tr class="separator:a21810b671ec68509499ee2d4f10a8a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5d5335ce4fc906636a2690155a7d72"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a5d5d5335ce4fc906636a2690155a7d72">isIndex</a> () const</td></tr>
<tr class="separator:a5d5d5335ce4fc906636a2690155a7d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8d0fc00420cfe321827ee74cbb0486"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#aaf8d0fc00420cfe321827ee74cbb0486">isFloat8E5M2</a> () const</td></tr>
<tr class="separator:aaf8d0fc00420cfe321827ee74cbb0486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d22785b272ee6ef090be454e54ddd8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a52d22785b272ee6ef090be454e54ddd8">isFloat8E4M3FN</a> () const</td></tr>
<tr class="separator:a52d22785b272ee6ef090be454e54ddd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8b70e6743511741effa71885d356d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#afa8b70e6743511741effa71885d356d3">isFloat8E5M2FNUZ</a> () const</td></tr>
<tr class="separator:afa8b70e6743511741effa71885d356d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7850880e12cbf8764d133207f94a4d31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a7850880e12cbf8764d133207f94a4d31">isFloat8E4M3FNUZ</a> () const</td></tr>
<tr class="separator:a7850880e12cbf8764d133207f94a4d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82cb40a3f43e1137698e31435b01529d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a82cb40a3f43e1137698e31435b01529d">isFloat8E4M3B11FNUZ</a> () const</td></tr>
<tr class="separator:a82cb40a3f43e1137698e31435b01529d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af077a551403812fae63d3ee3f9233d35"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#af077a551403812fae63d3ee3f9233d35">isBF16</a> () const</td></tr>
<tr class="separator:af077a551403812fae63d3ee3f9233d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a009c7555ce7c74ab581e0ac66a593"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ad5a009c7555ce7c74ab581e0ac66a593">isF16</a> () const</td></tr>
<tr class="separator:ad5a009c7555ce7c74ab581e0ac66a593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cde84bc1dbdaecf64df30e7c99e2106"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a6cde84bc1dbdaecf64df30e7c99e2106">isF32</a> () const</td></tr>
<tr class="separator:a6cde84bc1dbdaecf64df30e7c99e2106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075a66eef3b8dc3f5fd51eba8399ceb8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a075a66eef3b8dc3f5fd51eba8399ceb8">isF64</a> () const</td></tr>
<tr class="separator:a075a66eef3b8dc3f5fd51eba8399ceb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad943633969f919ce6169fb52a5cea1cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ad943633969f919ce6169fb52a5cea1cd">isF80</a> () const</td></tr>
<tr class="separator:ad943633969f919ce6169fb52a5cea1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6105a40d762d129e4b9766d43ff647f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ac6105a40d762d129e4b9766d43ff647f">isF128</a> () const</td></tr>
<tr class="separator:ac6105a40d762d129e4b9766d43ff647f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d16f5d47b21c67f4d49c02979c33724"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a1d16f5d47b21c67f4d49c02979c33724">isInteger</a> (unsigned width) const</td></tr>
<tr class="memdesc:a1d16f5d47b21c67f4d49c02979c33724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is an integer type with the specified width.  <a href="classmlir_1_1Type.html#a1d16f5d47b21c67f4d49c02979c33724">More...</a><br /></td></tr>
<tr class="separator:a1d16f5d47b21c67f4d49c02979c33724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53765d45f36d2bbff81bb81b286a9525"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a53765d45f36d2bbff81bb81b286a9525">isSignlessInteger</a> () const</td></tr>
<tr class="memdesc:a53765d45f36d2bbff81bb81b286a9525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a signless integer type (with the specified width).  <a href="classmlir_1_1Type.html#a53765d45f36d2bbff81bb81b286a9525">More...</a><br /></td></tr>
<tr class="separator:a53765d45f36d2bbff81bb81b286a9525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213fdac03ae27d597f277ac05ea30fca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a213fdac03ae27d597f277ac05ea30fca">isSignlessInteger</a> (unsigned width) const</td></tr>
<tr class="separator:a213fdac03ae27d597f277ac05ea30fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50385bcb919f49adab0f8f2521dc479f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a50385bcb919f49adab0f8f2521dc479f">isSignedInteger</a> () const</td></tr>
<tr class="memdesc:a50385bcb919f49adab0f8f2521dc479f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a signed integer type (with the specified width).  <a href="classmlir_1_1Type.html#a50385bcb919f49adab0f8f2521dc479f">More...</a><br /></td></tr>
<tr class="separator:a50385bcb919f49adab0f8f2521dc479f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920ada7270762d4e2f96d96f5b29a140"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a920ada7270762d4e2f96d96f5b29a140">isSignedInteger</a> (unsigned width) const</td></tr>
<tr class="separator:a920ada7270762d4e2f96d96f5b29a140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c30270dcbb289e5931b2ed1c4c6919"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a78c30270dcbb289e5931b2ed1c4c6919">isUnsignedInteger</a> () const</td></tr>
<tr class="memdesc:a78c30270dcbb289e5931b2ed1c4c6919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is an unsigned integer type (with the specified width).  <a href="classmlir_1_1Type.html#a78c30270dcbb289e5931b2ed1c4c6919">More...</a><br /></td></tr>
<tr class="separator:a78c30270dcbb289e5931b2ed1c4c6919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbb14dffe2d155b3f3f478ca216aca7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a8dbb14dffe2d155b3f3f478ca216aca7">isUnsignedInteger</a> (unsigned width) const</td></tr>
<tr class="separator:a8dbb14dffe2d155b3f3f478ca216aca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb142623709910125e07ecf1f9f2cdd5"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#aeb142623709910125e07ecf1f9f2cdd5">getIntOrFloatBitWidth</a> () const</td></tr>
<tr class="memdesc:aeb142623709910125e07ecf1f9f2cdd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bit width of an integer or a float type, assert failure on other types.  <a href="classmlir_1_1Type.html#aeb142623709910125e07ecf1f9f2cdd5">More...</a><br /></td></tr>
<tr class="separator:aeb142623709910125e07ecf1f9f2cdd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f738cb5a46aeb47df2e6243a11c41c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a26f738cb5a46aeb47df2e6243a11c41c">isSignlessIntOrIndex</a> () const</td></tr>
<tr class="memdesc:a26f738cb5a46aeb47df2e6243a11c41c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a signless integer or index type.  <a href="classmlir_1_1Type.html#a26f738cb5a46aeb47df2e6243a11c41c">More...</a><br /></td></tr>
<tr class="separator:a26f738cb5a46aeb47df2e6243a11c41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeff6b78a50b5d435c10e6c8927bbb7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#afeff6b78a50b5d435c10e6c8927bbb7d">isSignlessIntOrIndexOrFloat</a> () const</td></tr>
<tr class="memdesc:afeff6b78a50b5d435c10e6c8927bbb7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a signless integer, index, or float type.  <a href="classmlir_1_1Type.html#afeff6b78a50b5d435c10e6c8927bbb7d">More...</a><br /></td></tr>
<tr class="separator:afeff6b78a50b5d435c10e6c8927bbb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d6282ddfa213055b965f2db7eb9752"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ae8d6282ddfa213055b965f2db7eb9752">isSignlessIntOrFloat</a> () const</td></tr>
<tr class="memdesc:ae8d6282ddfa213055b965f2db7eb9752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true of this is a signless integer or a float type.  <a href="classmlir_1_1Type.html#ae8d6282ddfa213055b965f2db7eb9752">More...</a><br /></td></tr>
<tr class="separator:ae8d6282ddfa213055b965f2db7eb9752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f33529654fee149935f1e14cdf74305"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a7f33529654fee149935f1e14cdf74305">isIntOrIndex</a> () const</td></tr>
<tr class="memdesc:a7f33529654fee149935f1e14cdf74305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is an integer (of any signedness) or an index type.  <a href="classmlir_1_1Type.html#a7f33529654fee149935f1e14cdf74305">More...</a><br /></td></tr>
<tr class="separator:a7f33529654fee149935f1e14cdf74305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4295aaec59a8a864338a2b7dab0c935"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#aa4295aaec59a8a864338a2b7dab0c935">isIntOrFloat</a> () const</td></tr>
<tr class="memdesc:aa4295aaec59a8a864338a2b7dab0c935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is an integer (of any signedness) or a float type.  <a href="classmlir_1_1Type.html#aa4295aaec59a8a864338a2b7dab0c935">More...</a><br /></td></tr>
<tr class="separator:aa4295aaec59a8a864338a2b7dab0c935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69310264441dfb377a3789c8eedcdce7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a69310264441dfb377a3789c8eedcdce7">isIntOrIndexOrFloat</a> () const</td></tr>
<tr class="memdesc:a69310264441dfb377a3789c8eedcdce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is an integer (of any signedness), index, or float type.  <a href="classmlir_1_1Type.html#a69310264441dfb377a3789c8eedcdce7">More...</a><br /></td></tr>
<tr class="separator:a69310264441dfb377a3789c8eedcdce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034614f0e682699a53a6e967654caf12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a034614f0e682699a53a6e967654caf12">print</a> (raw_ostream &amp;os) const</td></tr>
<tr class="memdesc:a034614f0e682699a53a6e967654caf12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the current type.  <a href="classmlir_1_1Type.html#a034614f0e682699a53a6e967654caf12">More...</a><br /></td></tr>
<tr class="separator:a034614f0e682699a53a6e967654caf12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef996e7de5468067879322021956d167"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#aef996e7de5468067879322021956d167">print</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1AsmState.html">AsmState</a> &amp;state) const</td></tr>
<tr class="separator:aef996e7de5468067879322021956d167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace59879c4e15990d08093e040fabb957"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ace59879c4e15990d08093e040fabb957">dump</a> () const</td></tr>
<tr class="separator:ace59879c4e15990d08093e040fabb957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1035844c344d17a9e6081c6a0e101b80"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a1035844c344d17a9e6081c6a0e101b80">getAsOpaquePointer</a> () const</td></tr>
<tr class="memdesc:a1035844c344d17a9e6081c6a0e101b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for supporting PointerLikeTypeTraits.  <a href="classmlir_1_1Type.html#a1035844c344d17a9e6081c6a0e101b80">More...</a><br /></td></tr>
<tr class="separator:a1035844c344d17a9e6081c6a0e101b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e876063454fa81bf686800a35ea5aa8"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename T &gt; class Trait&gt; </td></tr>
<tr class="memitem:a5e876063454fa81bf686800a35ea5aa8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a5e876063454fa81bf686800a35ea5aa8">hasTrait</a> ()</td></tr>
<tr class="memdesc:a5e876063454fa81bf686800a35ea5aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the type was registered with a particular trait.  <a href="classmlir_1_1Type.html#a5e876063454fa81bf686800a35ea5aa8">More...</a><br /></td></tr>
<tr class="separator:a5e876063454fa81bf686800a35ea5aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fb8bd616ad5ba45b95885d7b90bd71"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmlir_1_1Type.html#a0da492d52032c9c9d4fe2a1768437e13">AbstractTy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a79fb8bd616ad5ba45b95885d7b90bd71">getAbstractType</a> () const</td></tr>
<tr class="memdesc:a79fb8bd616ad5ba45b95885d7b90bd71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the abstract type descriptor for this type.  <a href="classmlir_1_1Type.html#a79fb8bd616ad5ba45b95885d7b90bd71">More...</a><br /></td></tr>
<tr class="separator:a79fb8bd616ad5ba45b95885d7b90bd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecf0e72a7e9eb013e55c89040319e18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html#a89de246b01ef652963e1ddde953d62e7">ImplType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a8ecf0e72a7e9eb013e55c89040319e18">getImpl</a> () const</td></tr>
<tr class="memdesc:a8ecf0e72a7e9eb013e55c89040319e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> implementation.  <a href="classmlir_1_1Type.html#a8ecf0e72a7e9eb013e55c89040319e18">More...</a><br /></td></tr>
<tr class="separator:a8ecf0e72a7e9eb013e55c89040319e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f215adc2d7aef45aaee1884bd93bcdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a6f215adc2d7aef45aaee1884bd93bcdb">walkImmediateSubElements</a> (<a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt; walkAttrsFn, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Type.html">Type</a>)&gt; walkTypesFn) const</td></tr>
<tr class="memdesc:a6f215adc2d7aef45aaee1884bd93bcdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the immediately nested sub-attributes and sub-types.  <a href="classmlir_1_1Type.html#a6f215adc2d7aef45aaee1884bd93bcdb">More...</a><br /></td></tr>
<tr class="separator:a6f215adc2d7aef45aaee1884bd93bcdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22321e0d04aac43a6054e27d41846b5f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a22321e0d04aac43a6054e27d41846b5f">replaceImmediateSubElements</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; replAttrs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; replTypes) const</td></tr>
<tr class="memdesc:a22321e0d04aac43a6054e27d41846b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the immediately nested sub-attributes and sub-types with those provided.  <a href="classmlir_1_1Type.html#a22321e0d04aac43a6054e27d41846b5f">More...</a><br /></td></tr>
<tr class="separator:a22321e0d04aac43a6054e27d41846b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56116bb5e60101fe97b5af0bf3213de"><td class="memTemplParams" colspan="2">template&lt;WalkOrder Order = WalkOrder::PostOrder, typename... WalkFns&gt; </td></tr>
<tr class="memitem:ae56116bb5e60101fe97b5af0bf3213de"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ae56116bb5e60101fe97b5af0bf3213de">walk</a> (WalkFns &amp;&amp;...walkFns)</td></tr>
<tr class="memdesc:ae56116bb5e60101fe97b5af0bf3213de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk this type and all attibutes/types nested within using the provided walk functions.  <a href="classmlir_1_1Type.html#ae56116bb5e60101fe97b5af0bf3213de">More...</a><br /></td></tr>
<tr class="separator:ae56116bb5e60101fe97b5af0bf3213de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add89f8ee12e06fac685dc07a272b02b9"><td class="memTemplParams" colspan="2">template&lt;typename... ReplacementFns&gt; </td></tr>
<tr class="memitem:add89f8ee12e06fac685dc07a272b02b9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#add89f8ee12e06fac685dc07a272b02b9">replace</a> (ReplacementFns &amp;&amp;...replacementFns)</td></tr>
<tr class="memdesc:add89f8ee12e06fac685dc07a272b02b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively replace all of the nested sub-attributes and sub-types using the provided map functions.  <a href="classmlir_1_1Type.html#add89f8ee12e06fac685dc07a272b02b9">More...</a><br /></td></tr>
<tr class="separator:add89f8ee12e06fac685dc07a272b02b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a58b903c935dfc504b4f4e3f77939b113"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a58b903c935dfc504b4f4e3f77939b113">getFromOpaquePointer</a> (const void *pointer)</td></tr>
<tr class="separator:a58b903c935dfc504b4f4e3f77939b113"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a54af6c081e012a32bba9b650480c6c06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html#a89de246b01ef652963e1ddde953d62e7">ImplType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a54af6c081e012a32bba9b650480c6c06">impl</a> {nullptr}</td></tr>
<tr class="separator:a54af6c081e012a32bba9b650480c6c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a54ee333db7234f6ada1036072a24b877"><td class="memItemLeft" align="right" valign="top">::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a54ee333db7234f6ada1036072a24b877">hash_value</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> arg)</td></tr>
<tr class="separator:a54ee333db7234f6ada1036072a24b877"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Instances of the <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> class are uniqued, have an immutable identifier and an optional mutable component. </p>
<p>They wrap a pointer to the storage object owned by <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a>. Therefore, instances of <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> are passed around by value.</p>
<p>Some types are "primitives" meaning they do not have any parameters, for example the Index type. Parametric types have additional information that differentiates the types of the same class, for example the Integer type has bitwidth, making i8 and i16 belong to the same kind by be different instances of the IntegerType. <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> parameters are part of the unique immutable key. The mutable component of the type can be modified after the type is created, but cannot affect the identity of the type.</p>
<p>Types are constructed and uniqued via the '<a class="el" href="structmlir_1_1detail_1_1TypeUniquer.html" title="A utility class to get, or create, unique instances of types within an MLIRContext.">detail::TypeUniquer</a>' class.</p>
<p>Derived type classes are expected to implement several required implementation hooks:</p><ul>
<li>Optional:<ul>
<li>static <a class="el" href="structmlir_1_1LogicalResult.html" title="This class represents an efficient way to signal success or failure.">LogicalResult</a> verify( function_ref&lt;InFlightDiagnostic()&gt; emitError, Args... args)<ul>
<li>This method is invoked when calling the '<a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a73da59a295ce21e18919de2ad6a6bb2b" title="Get or create a new ConcreteT instance within the ctx.">TypeBase::get</a>/getChecked' methods to ensure that the arguments passed in are valid to construct a type instance with.</li>
<li>This method is expected to return failure if a type cannot be constructed with 'args', success otherwise.</li>
<li>'args' must correspond with the arguments passed into the '<a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a73da59a295ce21e18919de2ad6a6bb2b" title="Get or create a new ConcreteT instance within the ctx.">TypeBase::get</a>' call.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> storage objects inherit from <a class="el" href="classmlir_1_1TypeStorage.html" title="Base storage class appearing in a Type.">TypeStorage</a> and contain the following:</p><ul>
<li>The dialect that defined the type.</li>
<li>Any parameters of the type.</li>
<li>An optional mutable component. For non-parametric types, a convenience DefaultTypeStorage is provided. Parametric storage types must derive <a class="el" href="classmlir_1_1TypeStorage.html" title="Base storage class appearing in a Type.">TypeStorage</a> and respect the following:</li>
<li>Define a type alias, KeyTy, to a type that uniquely identifies the instance of the type.<ul>
<li>The key type must be constructible from the values passed into the <a class="el" href="structmlir_1_1detail_1_1TypeUniquer.html#a06c28682a1cf2b71c324cdd4cf0fb2a0" title="Get an uniqued instance of a type T.">detail::TypeUniquer::get</a> call.</li>
<li>If the KeyTy does not have an <a class="el" href="structllvm_1_1DenseMapInfo.html">llvm::DenseMapInfo</a> specialization, the storage class must define a hashing method: 'static unsigned hashKey(const KeyTy &amp;)'</li>
</ul>
</li>
<li>Provide a method, 'bool operator==(const KeyTy &amp;) const', to compare the storage instance against an instance of the key type.</li>
<li>Provide a static construction method: 'DerivedStorage *construct(TypeStorageAllocator &amp;, const KeyTy &amp;key)' that builds a unique instance of the derived storage. The arguments to this function are an allocator to store any uniqued data within the context and the key type for this storage.</li>
<li>If they have a mutable component, this component must not be a part of the key. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00074">74</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a0da492d52032c9c9d4fe2a1768437e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da492d52032c9c9d4fe2a1768437e13">&#9670;&nbsp;</a></span>AbstractTy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1Type.html#a0da492d52032c9c9d4fe2a1768437e13">mlir::Type::AbstractTy</a> =  <a class="el" href="classmlir_1_1AbstractType.html">AbstractType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00084">84</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="a89de246b01ef652963e1ddde953d62e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89de246b01ef652963e1ddde953d62e7">&#9670;&nbsp;</a></span>ImplType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1Type.html#a89de246b01ef652963e1ddde953d62e7">mlir::Type::ImplType</a> =  <a class="el" href="classmlir_1_1TypeStorage.html">TypeStorage</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00082">82</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="acd35e3f5186bd1c0e4c4f53f69aad716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd35e3f5186bd1c0e4c4f53f69aad716">&#9670;&nbsp;</a></span>TypeBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType , typename BaseType , typename StorageType , template&lt; typename T &gt; class... Traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1Type.html#acd35e3f5186bd1c0e4c4f53f69aad716">mlir::Type::TypeBase</a> =  <a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html">detail::StorageUserBase</a>&lt;ConcreteType, <a class="el" href="classBaseType.html">BaseType</a>, StorageType, <a class="el" href="structmlir_1_1detail_1_1TypeUniquer.html">detail::TypeUniquer</a>, Traits...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility class for implementing types. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00079">79</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a622149b48f6d7eaf0e42f8abea6ca65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622149b48f6d7eaf0e42f8abea6ca65e">&#9670;&nbsp;</a></span>Type() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mlir::Type::Type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="IR_2Types_8h_source.html#l00178">getFromOpaquePointer()</a>.</p>

</div>
</div>
<a id="aaa8871458ee7b2abdca3e94788ae3048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8871458ee7b2abdca3e94788ae3048">&#9670;&nbsp;</a></span>Type() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::Type::Type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Type.html#a89de246b01ef652963e1ddde953d62e7">ImplType</a> *&#160;</td>
          <td class="paramname"><em>impl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00087">87</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="a237023ae4dcab369d064457a10bcf518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237023ae4dcab369d064457a10bcf518">&#9670;&nbsp;</a></span>Type() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::Type::Type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1a9c3e06d3b23ad9457c13cb828a7c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a9c3e06d3b23ad9457c13cb828a7c48">&#9670;&nbsp;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">U mlir::Type::cast</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00321">321</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="ace59879c4e15990d08093e040fabb957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace59879c4e15990d08093e040fabb957">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Type::dump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l03592">3592</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

</div>
</div>
<a id="a6b8d33d03b9736dfcc3cc0e9351b1826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8d33d03b9736dfcc3cc0e9351b1826">&#9670;&nbsp;</a></span>dyn_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">U mlir::Type::dyn_cast</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00311">311</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="a33ca8bbee5e3e8a02e0df18897981edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ca8bbee5e3e8a02e0df18897981edf">&#9670;&nbsp;</a></span>dyn_cast_or_null()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">U mlir::Type::dyn_cast_or_null</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00316">316</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="a79fb8bd616ad5ba45b95885d7b90bd71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79fb8bd616ad5ba45b95885d7b90bd71">&#9670;&nbsp;</a></span>getAbstractType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmlir_1_1Type.html#a0da492d52032c9c9d4fe2a1768437e13">AbstractTy</a>&amp; mlir::Type::getAbstractType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the abstract type descriptor for this type. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00189">189</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2Types_8h_source.html#l00184">hasTrait()</a>, <a class="el" href="IR_2Types_8h_source.html#l00207">replaceImmediateSubElements()</a>, and <a class="el" href="IR_2Types_8h_source.html#l00196">walkImmediateSubElements()</a>.</p>

</div>
</div>
<a id="a1035844c344d17a9e6081c6a0e101b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1035844c344d17a9e6081c6a0e101b80">&#9670;&nbsp;</a></span>getAsOpaquePointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void* mlir::Type::getAsOpaquePointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for supporting PointerLikeTypeTraits. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00175">175</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00236">impl</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2Types_8h_source.html#l00361">llvm::PointerLikeTypeTraits&lt; mlir::Type &gt;::getAsVoidPointer()</a>.</p>

</div>
</div>
<a id="a3951cad794a5bc5ad086158c20f8e50e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3951cad794a5bc5ad086158c20f8e50e">&#9670;&nbsp;</a></span>getContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> * Type::getContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a> in which this type was uniqued. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00035">35</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DLTI_8cpp_source.html#l00195">combineOneSpec()</a>, <a class="el" href="FakeQuantSupport_8cpp_source.html#l00108">mlir::quant::fakeQuantAttrsToType()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00065">mlir::gpu::MMAMatrixType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l01174">mlir::spirv::MatrixType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00538">mlir::spirv::RuntimeArrayType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00232">mlir::spirv::CooperativeMatrixNVType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00298">mlir::spirv::JointMatrixINTELType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00051">mlir::spirv::ArrayType::get()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00371">mlir::quant::CalibratedQuantizedType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00807">mlir::spirv::SampledImageType::get()</a>, <a class="el" href="DLTI_8cpp_source.html#l00056">mlir::DataLayoutEntryAttr::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00481">mlir::spirv::PointerType::get()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00304">mlir::quant::UniformQuantizedPerAxisType::get()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00253">mlir::quant::UniformQuantizedType::get()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00217">mlir::quant::AnyQuantizedType::get()</a>, <a class="el" href="CodegenUtils_8h_source.html#l00258">mlir::sparse_tensor::get1DMemRefType()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00071">mlir::gpu::MMAMatrixType::getChecked()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l01178">mlir::spirv::MatrixType::getChecked()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00376">mlir::quant::CalibratedQuantizedType::getChecked()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00812">mlir::spirv::SampledImageType::getChecked()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00314">mlir::quant::UniformQuantizedPerAxisType::getChecked()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00262">mlir::quant::UniformQuantizedType::getChecked()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00226">mlir::quant::AnyQuantizedType::getChecked()</a>, <a class="el" href="Value_8h_source.html#l00125">mlir::Value::getContext()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00133">mlir::detail::getDefaultABIAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00186">mlir::detail::getDefaultPreferredAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00051">mlir::detail::getDefaultTypeSizeInBits()</a>, <a class="el" href="PDLInterp_8cpp_source.html#l00239">getGetValueTypeOpValueType()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00118">getI1SameShape()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00846">mlir::bufferization::getMemRefTypeWithFullyDynamicLayout()</a>, <a class="el" href="SCFToOpenMP_8cpp_source.html#l00216">getPointerType()</a>, <a class="el" href="MMAUtils_8cpp_source.html#l00154">getRegisterIndexToTileOffsetMap()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00103">mlir::memref::getTensorTypeFromMemRefType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00991">getUnaryOpResultType()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l02389">getValAndBoolStructType()</a>, <a class="el" href="NVGPUToNVVM_8cpp_source.html#l00029">inferIntrinsicResultType()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00913">mlir::LLVM::isCompatibleType()</a>, <a class="el" href="MemRefMemorySlot_8cpp_source.html#l00066">isSupportedElementType()</a>, <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html#l00162">mlir::spirv::MemorySpaceToStorageClassConverter::MemorySpaceToStorageClassConverter()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00539">mlir::populateAMDGPUToROCDLConversionPatterns()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00521">mlir::UnrankedMemRefDescriptor::sizeBasePtr()</a>, and <a class="el" href="Arith_2Transforms_2EmulateWideInt_8cpp_source.html#l01093">mlir::arith::WideIntEmulationConverter::WideIntEmulationConverter()</a>.</p>

</div>
</div>
<a id="a21810b671ec68509499ee2d4f10a8a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21810b671ec68509499ee2d4f10a8a6b">&#9670;&nbsp;</a></span>getDialect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Dialect.html">Dialect</a> Type::getDialect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dialect this type is registered to. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00118">118</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="PDLTypes_8cpp_source.html#l00058">mlir::pdl::PDLType::classof()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00027">mlir::quant::QuantizedType::classof()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00726">mlir::spirv::SPIRVType::classof()</a>, <a class="el" href="DLTI_8cpp_source.html#l00195">combineOneSpec()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00313">mlir::TensorType::isValidElementType()</a>, and <a class="el" href="SPIRVDialect_8cpp_source.html#l00155">parseAndVerifyType()</a>.</p>

</div>
</div>
<a id="a58b903c935dfc504b4f4e3f77939b113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b903c935dfc504b4f4e3f77939b113">&#9670;&nbsp;</a></span>getFromOpaquePointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Type.html">Type</a> mlir::Type::getFromOpaquePointer </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00178">178</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1Type.html#a622149b48f6d7eaf0e42f8abea6ca65e">Type()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00052">mlir::DiagnosticArgument::getAsType()</a>, and <a class="el" href="IR_2Types_8h_source.html#l00364">llvm::PointerLikeTypeTraits&lt; mlir::Type &gt;::getFromVoidPointer()</a>.</p>

</div>
</div>
<a id="a8ecf0e72a7e9eb013e55c89040319e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ecf0e72a7e9eb013e55c89040319e18">&#9670;&nbsp;</a></span>getImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html#a89de246b01ef652963e1ddde953d62e7">ImplType</a>* mlir::Type::getImpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> implementation. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00192">192</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00236">impl</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2Types_8h_source.html#l00397">llvm::CastInfo&lt; To, From, std::enable_if_t&lt; std::is_same_v&lt; mlir::Type, std::remove_const_t&lt; From &gt; &gt;||std::is_base_of_v&lt; mlir::Type, From &gt; &gt; &gt;::doCast()</a>.</p>

</div>
</div>
<a id="aeb142623709910125e07ecf1f9f2cdd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb142623709910125e07ecf1f9f2cdd5">&#9670;&nbsp;</a></span>getIntOrFloatBitWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Type::getIntOrFloatBitWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the bit width of an integer or a float type, assert failure on other types. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00122">122</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00149">areSameBitwidthScalarType()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00359">buildAttributeAPInt()</a>, <a class="el" href="MathToFuncs_8cpp_source.html#l00651">createCtlzFunc()</a>, <a class="el" href="MathToFuncs_8cpp_source.html#l00185">createElementIPowIFunc()</a>, <a class="el" href="SCFToOpenMP_8cpp_source.html#l00252">declareReduction()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00088">deduceCanonicalResource()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00090">findEntryForIntegerType()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00216">mlir::sparse_tensor::genIndexLoad()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00055">getBitWidth()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00621">mlir::spirv::ScalarType::getCapabilities()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00051">mlir::detail::getDefaultTypeSizeInBits()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00034">mlir::detail::getDenseElementBitWidth()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00590">mlir::spirv::ScalarType::getExtensions()</a>, <a class="el" href="Builders_8cpp_source.html#l00225">mlir::Builder::getIntegerAttr()</a>, <a class="el" href="MMAUtils_8cpp_source.html#l00173">mlir::nvgpu::getLaneIdAndValueIdToOperandCoord()</a>, <a class="el" href="MMAUtils_8cpp_source.html#l00209">mlir::nvgpu::getLdMatrixParams()</a>, <a class="el" href="VectorToSPIRV_8cpp_source.html#l00042">getNumBits()</a>, <a class="el" href="MMAUtils_8cpp_source.html#l00154">getRegisterIndexToTileOffsetMap()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00082">getScalarOrElementWidth()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00709">mlir::spirv::ScalarType::getSizeInBytes()</a>, <a class="el" href="MMAUtils_8cpp_source.html#l00039">getTileShape()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00141">getTypeNumBytes()</a>, <a class="el" href="MMAUtils_8cpp_source.html#l00087">mlir::nvgpu::inferTileWidthInBits()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00215">mlir::GPUPrintfOpToHIPLowering::matchAndRewrite()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00934">mlir::detail::Parser::parseDenseArrayAttr()</a>, and <a class="el" href="ControlFlowOps_8cpp_source.html#l00494">parseSwitchOpCases()</a>.</p>

</div>
</div>
<a id="accf7dade447f73f5b04c46fcf616b68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf7dade447f73f5b04c46fcf616b68c">&#9670;&nbsp;</a></span>getTypeID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a> mlir::Type::getTypeID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a unique identifier for the concrete type. </p>
<p>This is used to support dynamic type casting. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00112">112</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00460">mlir::DataLayout::getTypeABIAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00472">mlir::DataLayout::getTypePreferredAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00436">mlir::DataLayout::getTypeSize()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00448">mlir::DataLayout::getTypeSizeInBits()</a>, and <a class="el" href="ExtensibleDialect_8h_source.html#l00339">mlir::DynamicType::isa()</a>.</p>

</div>
</div>
<a id="a5e876063454fa81bf686800a35ea5aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e876063454fa81bf686800a35ea5aa8">&#9670;&nbsp;</a></span>hasTrait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename T &gt; class Trait&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::Type::hasTrait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the type was registered with a particular trait. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00184">184</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00189">getAbstractType()</a>, and <a class="el" href="TypeSupport_8h_source.html#l00084">mlir::AbstractType::hasTrait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ExtensibleDialect_8cpp_source.html#l00152">mlir::DynamicType::classof()</a>.</p>

</div>
</div>
<a id="adcd295cf88ab7faa33601d3bbee5c4b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd295cf88ab7faa33601d3bbee5c4b8">&#9670;&nbsp;</a></span>isa()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Tys&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::Type::isa</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00301">301</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="a46a0015618ae48c270a23609298e6568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a0015618ae48c270a23609298e6568">&#9670;&nbsp;</a></span>isa_and_nonnull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Tys&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::Type::isa_and_nonnull</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00306">306</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LLVMDialect_8cpp_source.html#l00497">destructureIndices()</a>.</p>

</div>
</div>
<a id="af077a551403812fae63d3ee3f9233d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af077a551403812fae63d3ee3f9233d35">&#9670;&nbsp;</a></span>isBF16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isBF16 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00048">48</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCFToOpenMP_8cpp_source.html#l00138">fltSemanticsForType()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00582">mlir::spirv::ScalarType::isValid()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00340">mfmaOpToIntrinsic()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00155">parseAndVerifyType()</a>, and <a class="el" href="CodegenUtils_8cpp_source.html#l00155">mlir::sparse_tensor::primaryTypeEncoding()</a>.</p>

</div>
</div>
<a id="ac6105a40d762d129e4b9766d43ff647f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6105a40d762d129e4b9766d43ff647f">&#9670;&nbsp;</a></span>isF128()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isF128 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00053">53</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCFToOpenMP_8cpp_source.html#l00138">fltSemanticsForType()</a>.</p>

</div>
</div>
<a id="ad5a009c7555ce7c74ab581e0ac66a593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a009c7555ce7c74ab581e0ac66a593">&#9670;&nbsp;</a></span>isF16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isF16 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00049">49</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="PolynomialApproximation_8cpp_source.html#l00166">floatCst()</a>, <a class="el" href="SCFToOpenMP_8cpp_source.html#l00138">fltSemanticsForType()</a>, <a class="el" href="MMAUtils_8cpp_source.html#l00100">mlir::nvgpu::getMmaSyncRegisterType()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00088">mlir::gpu::MMAMatrixType::isValidElementType()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00340">mfmaOpToIntrinsic()</a>, and <a class="el" href="CodegenUtils_8cpp_source.html#l00155">mlir::sparse_tensor::primaryTypeEncoding()</a>.</p>

</div>
</div>
<a id="a6cde84bc1dbdaecf64df30e7c99e2106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cde84bc1dbdaecf64df30e7c99e2106">&#9670;&nbsp;</a></span>isF32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isF32 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00050">50</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArithToSPIRV_8cpp_source.html#l00300">convertFloatAttr()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00166">floatCst()</a>, <a class="el" href="SCFToOpenMP_8cpp_source.html#l00138">fltSemanticsForType()</a>, <a class="el" href="MMAUtils_8cpp_source.html#l00100">mlir::nvgpu::getMmaSyncRegisterType()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00088">mlir::gpu::MMAMatrixType::isValidElementType()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00340">mfmaOpToIntrinsic()</a>, and <a class="el" href="CodegenUtils_8cpp_source.html#l00155">mlir::sparse_tensor::primaryTypeEncoding()</a>.</p>

</div>
</div>
<a id="a075a66eef3b8dc3f5fd51eba8399ceb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075a66eef3b8dc3f5fd51eba8399ceb8">&#9670;&nbsp;</a></span>isF64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isF64 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00051">51</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCFToOpenMP_8cpp_source.html#l00138">fltSemanticsForType()</a>, <a class="el" href="MMAUtils_8cpp_source.html#l00100">mlir::nvgpu::getMmaSyncRegisterType()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00340">mfmaOpToIntrinsic()</a>, and <a class="el" href="CodegenUtils_8cpp_source.html#l00155">mlir::sparse_tensor::primaryTypeEncoding()</a>.</p>

</div>
</div>
<a id="ad943633969f919ce6169fb52a5cea1cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad943633969f919ce6169fb52a5cea1cd">&#9670;&nbsp;</a></span>isF80()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isF80 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00052">52</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCFToOpenMP_8cpp_source.html#l00138">fltSemanticsForType()</a>.</p>

</div>
</div>
<a id="a82cb40a3f43e1137698e31435b01529d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82cb40a3f43e1137698e31435b01529d">&#9670;&nbsp;</a></span>isFloat8E4M3B11FNUZ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isFloat8E4M3B11FNUZ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00045">45</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

</div>
</div>
<a id="a52d22785b272ee6ef090be454e54ddd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d22785b272ee6ef090be454e54ddd8">&#9670;&nbsp;</a></span>isFloat8E4M3FN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isFloat8E4M3FN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00038">38</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

</div>
</div>
<a id="a7850880e12cbf8764d133207f94a4d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7850880e12cbf8764d133207f94a4d31">&#9670;&nbsp;</a></span>isFloat8E4M3FNUZ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isFloat8E4M3FNUZ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00042">42</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00340">mfmaOpToIntrinsic()</a>, and <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00539">mlir::populateAMDGPUToROCDLConversionPatterns()</a>.</p>

</div>
</div>
<a id="aaf8d0fc00420cfe321827ee74cbb0486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf8d0fc00420cfe321827ee74cbb0486">&#9670;&nbsp;</a></span>isFloat8E5M2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isFloat8E5M2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00037">37</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

</div>
</div>
<a id="afa8b70e6743511741effa71885d356d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8b70e6743511741effa71885d356d3">&#9670;&nbsp;</a></span>isFloat8E5M2FNUZ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isFloat8E5M2FNUZ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00039">39</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00340">mfmaOpToIntrinsic()</a>, and <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00539">mlir::populateAMDGPUToROCDLConversionPatterns()</a>.</p>

</div>
</div>
<a id="a5d5d5335ce4fc906636a2690155a7d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d5d5335ce4fc906636a2690155a7d72">&#9670;&nbsp;</a></span>isIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00055">55</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArithOps_8cpp_source.html#l01473">areIndexCastCompatible()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00046">assertValidValueDim()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00359">buildAttributeAPInt()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00339">ceilDivPositive()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00235">mlir::ValueBoundsConstraintSet::computeBound()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00087">mlir::convertScalarToDtype()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00034">mlir::detail::getDenseElementBitWidth()</a>, <a class="el" href="Builders_8cpp_source.html#l00225">mlir::Builder::getIntegerAttr()</a>, <a class="el" href="InferIntRangeInterface_8cpp_source.html#l00030">mlir::ConstantIntRanges::getStorageBitwidth()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00066">mlir::getValueOrCreateCastToIndexLike()</a>, <a class="el" href="DecomposeLinalgOps_8cpp_source.html#l00132">getZero()</a>, <a class="el" href="Index_2IR_2InferIntRangeInterfaceImpls_8cpp_source.html#l00180">inferIndexCast()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l00753">isMatchingWidth()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00266">mlir::affine::isValidDim()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01098">isValidIntOrFloat()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00363">mlir::affine::isValidSymbol()</a>, <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00035">mlir::affine::materializeComputedBound()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00094">mlir::sparse_tensor::overheadTypeEncoding()</a>, and <a class="el" href="Arith_2Transforms_2ReifyValueBounds_8cpp_source.html#l00065">reifyValueBound()</a>.</p>

</div>
</div>
<a id="a1d16f5d47b21c67f4d49c02979c33724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d16f5d47b21c67f4d49c02979c33724">&#9670;&nbsp;</a></span>isInteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isInteger </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is an integer type with the specified width. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00058">58</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefToSPIRV_8cpp_source.html#l00144">castBoolToIntN()</a>, <a class="el" href="MemRefToSPIRV_8cpp_source.html#l00135">castIntNToBool()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00891">mlir::DenseElementsAttr::get()</a>, <a class="el" href="AMDGPUDialect_8cpp_source.html#l00098">getConstantUint32()</a>, <a class="el" href="MMAUtils_8cpp_source.html#l00100">mlir::nvgpu::getMmaSyncRegisterType()</a>, <a class="el" href="MathToSPIRV_8cpp_source.html#l00035">getScalarOrVectorI32Constant()</a>, <a class="el" href="ArithToSPIRV_8cpp_source.html#l00322">isBoolScalarOrVector()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l00753">isMatchingWidth()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00674">mlir::DenseElementsAttr::isValidBool()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00088">mlir::gpu::MMAMatrixType::isValidElementType()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00340">mfmaOpToIntrinsic()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00934">mlir::detail::Parser::parseDenseArrayAttr()</a>, and <a class="el" href="CodegenUtils_8cpp_source.html#l00155">mlir::sparse_tensor::primaryTypeEncoding()</a>.</p>

</div>
</div>
<a id="aa4295aaec59a8a864338a2b7dab0c935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4295aaec59a8a864338a2b7dab0c935">&#9670;&nbsp;</a></span>isIntOrFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isIntOrFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is an integer (of any signedness) or a float type. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00116">116</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00149">areSameBitwidthScalarType()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00055">getBitWidth()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00082">getScalarOrElementWidth()</a>, <a class="el" href="MemRefToSPIRV_8cpp_source.html#l00094">isAllocationSupported()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00737">mlir::spirv::SPIRVType::isScalarOrVector()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00381">mlir::GPUPrintfOpToVPrintfLowering::matchAndRewrite()</a>, and <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00348">ConvertAccessChain::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a7f33529654fee149935f1e14cdf74305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f33529654fee149935f1e14cdf74305">&#9670;&nbsp;</a></span>isIntOrIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isIntOrIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is an integer (of any signedness) or an index type. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00112">112</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodegenUtils_8cpp_source.html#l00243">mlir::sparse_tensor::genIsNonzero()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00112">isSupportedCombiningKind()</a>, and <a class="el" href="AttributeParser_8cpp_source.html#l00934">mlir::detail::Parser::parseDenseArrayAttr()</a>.</p>

</div>
</div>
<a id="a69310264441dfb377a3789c8eedcdce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69310264441dfb377a3789c8eedcdce7">&#9670;&nbsp;</a></span>isIntOrIndexOrFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isIntOrIndexOrFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is an integer (of any signedness), index, or float type. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00120">120</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00891">mlir::DenseElementsAttr::get()</a>, <a class="el" href="DecomposeLinalgOps_8cpp_source.html#l00132">getZero()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01951">mlir::vector::isBroadcastableTo()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00112">isSupportedCombiningKind()</a>, <a class="el" href="MathToSPIRV_8cpp_source.html#l00054">isSupportedSourceType()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00397">mlir::BaseMemRefType::isValidElementType()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00934">mlir::detail::Parser::parseDenseArrayAttr()</a>, and <a class="el" href="SPIRVDialect_8cpp_source.html#l00959">verifyRegionAttribute()</a>.</p>

</div>
</div>
<a id="a50385bcb919f49adab0f8f2521dc479f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50385bcb919f49adab0f8f2521dc479f">&#9670;&nbsp;</a></span>isSignedInteger() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isSignedInteger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is a signed integer type (with the specified width). </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00076">76</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttributeParser_8cpp_source.html#l00359">buildAttributeAPInt()</a>, <a class="el" href="Builders_8cpp_source.html#l00225">mlir::Builder::getIntegerAttr()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00037">isSignedIntegerOrVector()</a>, and <a class="el" href="GPUDialect_8cpp_source.html#l00088">mlir::gpu::MMAMatrixType::isValidElementType()</a>.</p>

</div>
</div>
<a id="a920ada7270762d4e2f96d96f5b29a140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a920ada7270762d4e2f96d96f5b29a140">&#9670;&nbsp;</a></span>isSignedInteger() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isSignedInteger </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00082">82</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

</div>
</div>
<a id="a53765d45f36d2bbff81bb81b286a9525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53765d45f36d2bbff81bb81b286a9525">&#9670;&nbsp;</a></span>isSignlessInteger() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isSignlessInteger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is a signless integer type (with the specified width). </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00064">64</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArithOps_8cpp_source.html#l01473">areIndexCastCompatible()</a>, and <a class="el" href="ArithOps_8cpp_source.html#l00206">mlir::arith::ConstantIntOp::build()</a>.</p>

</div>
</div>
<a id="a213fdac03ae27d597f277ac05ea30fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213fdac03ae27d597f277ac05ea30fca">&#9670;&nbsp;</a></span>isSignlessInteger() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isSignlessInteger </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00070">70</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

</div>
</div>
<a id="ae8d6282ddfa213055b965f2db7eb9752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d6282ddfa213055b965f2db7eb9752">&#9670;&nbsp;</a></span>isSignlessIntOrFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isSignlessIntOrFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true of this is a signless integer or a float type. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00108">108</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

</div>
</div>
<a id="a26f738cb5a46aeb47df2e6243a11c41c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f738cb5a46aeb47df2e6243a11c41c">&#9670;&nbsp;</a></span>isSignlessIntOrIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isSignlessIntOrIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is a signless integer or index type. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00100">100</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

</div>
</div>
<a id="afeff6b78a50b5d435c10e6c8927bbb7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeff6b78a50b5d435c10e6c8927bbb7d">&#9670;&nbsp;</a></span>isSignlessIntOrIndexOrFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isSignlessIntOrIndexOrFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is a signless integer, index, or float type. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00104">104</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgOps_8cpp_source.html#l01842">appendMangledType()</a>.</p>

</div>
</div>
<a id="a78c30270dcbb289e5931b2ed1c4c6919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c30270dcbb289e5931b2ed1c4c6919">&#9670;&nbsp;</a></span>isUnsignedInteger() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isUnsignedInteger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is an unsigned integer type (with the specified width). </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00088">88</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00046">isUnsignedIntegerOrVector()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00088">mlir::gpu::MMAMatrixType::isValidElementType()</a>, and <a class="el" href="AttributeParser_8cpp_source.html#l00405">mlir::detail::Parser::parseDecOrHexAttr()</a>.</p>

</div>
</div>
<a id="a8dbb14dffe2d155b3f3f478ca216aca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dbb14dffe2d155b3f3f478ca216aca7">&#9670;&nbsp;</a></span>isUnsignedInteger() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isUnsignedInteger </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00094">94</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

</div>
</div>
<a id="afeb8b20e59002a0fedfcb93e314b416f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeb8b20e59002a0fedfcb93e314b416f">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::Type::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00095">95</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00236">impl</a>.</p>

</div>
</div>
<a id="ac516f7c8eb957068555b5781d78f23af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac516f7c8eb957068555b5781d78f23af">&#9670;&nbsp;</a></span>operator!()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::Type::operator! </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00097">97</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="ad1be45203a0010965388d41e712dc268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1be45203a0010965388d41e712dc268">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlir_1_1Type.html#ac516f7c8eb957068555b5781d78f23af">mlir::Type::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00094">94</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="a860e9e7612215565aadad622ccf4cbb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860e9e7612215565aadad622ccf4cbb0">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a>&amp; mlir::Type::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac53df1249058e8c2ec0fa70f172f0b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac53df1249058e8c2ec0fa70f172f0b59">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::Type::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00093">93</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00236">impl</a>.</p>

</div>
</div>
<a id="a034614f0e682699a53a6e967654caf12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a034614f0e682699a53a6e967654caf12">&#9670;&nbsp;</a></span>print() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Type::print </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the current type. </p>

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l03579">3579</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="MathToFuncs_8cpp_source.html#l00651">createCtlzFunc()</a>, and <a class="el" href="IR_2Types_8h_source.html#l00239">mlir::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a id="aef996e7de5468067879322021956d167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef996e7de5468067879322021956d167">&#9670;&nbsp;</a></span>print() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Type::print </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmState.html">AsmState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l03588">3588</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

</div>
</div>
<a id="add89f8ee12e06fac685dc07a272b02b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add89f8ee12e06fac685dc07a272b02b9">&#9670;&nbsp;</a></span>replace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... ReplacementFns&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::Type::replace </td>
          <td>(</td>
          <td class="paramtype">ReplacementFns &amp;&amp;...&#160;</td>
          <td class="paramname"><em>replacementFns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively replace all of the nested sub-attributes and sub-types using the provided map functions. </p>
<p>Returns nullptr in the case of failure. See <code><a class="el" href="classmlir_1_1AttrTypeReplacer.html" title="AttrTypeReplacer.">AttrTypeReplacer</a></code> for information on the support replacement function types. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00228">228</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="AttrTypeSubElements_8cpp_source.html#l00073">mlir::AttrTypeReplacer::addReplacement()</a>, and <a class="el" href="AttrTypeSubElements_8cpp_source.html#l00222">mlir::AttrTypeReplacer::replace()</a>.</p>

</div>
</div>
<a id="a22321e0d04aac43a6054e27d41846b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22321e0d04aac43a6054e27d41846b5f">&#9670;&nbsp;</a></span>replaceImmediateSubElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::Type::replaceImmediateSubElements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>replAttrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt;&#160;</td>
          <td class="paramname"><em>replTypes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the immediately nested sub-attributes and sub-types with those provided. </p>
<p>The order of the provided elements is derived from the order of the elements returned by the callbacks of <code>walkImmediateSubElements</code>. The element at index 0 would replace the very first attribute given by <code>walkImmediateSubElements</code>. On success, the new instance with the values replaced is returned. If replacement fails, nullptr is returned. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00207">207</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00189">getAbstractType()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00025">mlir::AbstractType::replaceImmediateSubElements()</a>.</p>

</div>
</div>
<a id="ae56116bb5e60101fe97b5af0bf3213de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae56116bb5e60101fe97b5af0bf3213de">&#9670;&nbsp;</a></span>walk()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;WalkOrder Order = WalkOrder::PostOrder, typename... WalkFns&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::Type::walk </td>
          <td>(</td>
          <td class="paramtype">WalkFns &amp;&amp;...&#160;</td>
          <td class="paramname"><em>walkFns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Walk this type and all attibutes/types nested within using the provided walk functions. </p>
<p>See <code><a class="el" href="classmlir_1_1AttrTypeWalker.html" title="AttrTypeWalker.">AttrTypeWalker</a></code> for information on the supported walk function types. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00217">217</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="AttrTypeSubElements_8h_source.html#l00068">mlir::AttrTypeWalker::addWalk()</a>, and <a class="el" href="AttrTypeSubElements_8h_source.html#l00041">mlir::AttrTypeWalker::walk()</a>.</p>

</div>
</div>
<a id="a6f215adc2d7aef45aaee1884bd93bcdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f215adc2d7aef45aaee1884bd93bcdb">&#9670;&nbsp;</a></span>walkImmediateSubElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::Type::walkImmediateSubElements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt;&#160;</td>
          <td class="paramname"><em>walkAttrsFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Type.html">Type</a>)&gt;&#160;</td>
          <td class="paramname"><em>walkTypesFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Walk all of the immediately nested sub-attributes and sub-types. </p>
<p>This method does not recurse into sub elements. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00196">196</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00189">getAbstractType()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00019">mlir::AbstractType::walkImmediateSubElements()</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a54ee333db7234f6ada1036072a24b877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ee333db7234f6ada1036072a24b877">&#9670;&nbsp;</a></span>hash_value</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">::llvm::hash_code hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00296">296</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a54af6c081e012a32bba9b650480c6c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54af6c081e012a32bba9b650480c6c06">&#9670;&nbsp;</a></span>impl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html#a89de246b01ef652963e1ddde953d62e7">ImplType</a>* mlir::Type::impl {nullptr}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00236">236</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2Types_8h_source.html#l00175">getAsOpaquePointer()</a>, <a class="el" href="IR_2Types_8h_source.html#l00192">getImpl()</a>, <a class="el" href="IR_2Types_8h_source.html#l00095">operator bool()</a>, and <a class="el" href="IR_2Types_8h_source.html#l00093">operator==()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/IR/<a class="el" href="IR_2Types_8h_source.html">Types.h</a></li>
<li>lib/IR/<a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a></li>
<li>lib/IR/<a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a></li>
<li>lib/TableGen/<a class="el" href="Type_8cpp_source.html">Type.cpp</a></li>
<li>lib/Tools/PDLL/AST/<a class="el" href="NodePrinter_8cpp_source.html">NodePrinter.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 30 2023 16:34:18 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
