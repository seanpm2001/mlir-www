<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Chapter 2: Adding a Simple New Transformation Operation - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.80.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>Chapter 2: Adding a Simple New Transformation Operation</h1><h2 id=setting-up-to-add-new-transformations>Setting Up to Add New Transformations&nbsp;<a class=headline-hash href=#setting-up-to-add-new-transformations>Â¶</a></h2><p>Before defining a new transform operation, we need to choose where its implementation should be located. While MLIR encourages upstream contributions, it is not always possible or even desirable to modify the main Transform dialect, for example, if the transformation is specific to some out-of-tree dialect that is not itself available upstream.</p><p>The Transform dialect uses the dialect extension mechanism to allow additional operations to be injected without modifying the dialect itself. Dialect extensions are registered with the context and loaded when the dialect itself is loaded. Extension definition is straightforward:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=c1>// In MyExtension.cpp.
</span><span class=c1></span><span class=cp>#include</span> <span class=cpf>&#34;mlir/Dialect/Transform/IR/TransformDialect.h&#34;</span><span class=cp>
</span><span class=cp></span>
<span class=c1>// Define a new transform dialect extension. This uses the CRTP idiom to identify
</span><span class=c1>// extensions.
</span><span class=c1></span><span class=k>class</span> <span class=nc>MyExtension</span> <span class=o>:</span> <span class=k>public</span> <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>transform</span><span class=o>::</span><span class=n>TransformDialectExtension</span><span class=o>&lt;</span><span class=n>MyExtension</span><span class=o>&gt;</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
  <span class=c1>// The extension must derive the base constructor.
</span><span class=c1></span>  <span class=k>using</span> <span class=n>Base</span><span class=o>::</span><span class=n>Base</span><span class=p>;</span>

  <span class=c1>// This function initializes the extension, similarly to `initialize` in dialect 
</span><span class=c1></span>  <span class=c1>// definitions. List individual operations and dependent dialects here.
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>init</span><span class=p>();</span>
<span class=p>};</span>

<span class=kt>void</span> <span class=n>MyExtension</span><span class=o>::</span><span class=n>init</span><span class=p>()</span> <span class=p>{</span>
  <span class=c1>// Similarly to dialects, an extension can declare a dependent dialect. This dialect 
</span><span class=c1></span>  <span class=c1>// will be loaded along with the extension and, therefore, along with the Transform 
</span><span class=c1></span>  <span class=c1>// dialect. Only declare as dependent the dialects that contain the attributes or 
</span><span class=c1></span>  <span class=c1>// types used by transform operations. Do NOT declare as dependent the dialects 
</span><span class=c1></span>  <span class=c1>// produced during the transformation.
</span><span class=c1></span>  <span class=c1>// declareDependentDialect&lt;MyDialect&gt;();
</span><span class=c1></span>
  <span class=c1>// When transformations are applied, they may produce new operations from previously
</span><span class=c1></span>  <span class=c1>// unloaded dialects. Typically, a pass would need to declare itself dependent on
</span><span class=c1></span>  <span class=c1>// the dialects containing such new operations. To avoid confusion with the dialects
</span><span class=c1></span>  <span class=c1>// the extension itself depends on, the Transform dialects differentiates between:
</span><span class=c1></span>  <span class=c1>//   - dependent dialects, which are used by the transform operations, and
</span><span class=c1></span>  <span class=c1>//   - generated dialects, which contain the entities (attributes, operations, 
</span><span class=c1></span>  <span class=c1>//     types) that may be produced by applying the transformation even when not
</span><span class=c1></span>  <span class=c1>//     present in the original payload IR.
</span><span class=c1></span>  <span class=c1>// In the following chapter, we will be add operations that generate function calls
</span><span class=c1></span>  <span class=c1>// and structured control flow operations, so let&#39;s declare the corresponding
</span><span class=c1></span>  <span class=c1>// dialects as generated.
</span><span class=c1></span>  <span class=n>declareGeneratedDialect</span><span class=o>&lt;::</span><span class=n>mlir</span><span class=o>::</span><span class=n>scf</span><span class=o>::</span><span class=n>SCFDialect</span><span class=o>&gt;</span><span class=p>();</span>
  <span class=n>declareGeneratedDialect</span><span class=o>&lt;::</span><span class=n>mlir</span><span class=o>::</span><span class=n>func</span><span class=o>::</span><span class=n>FuncDialect</span><span class=o>&gt;</span><span class=p>();</span>

  <span class=c1>// Finally, we register the additional transform operations with the dialect.
</span><span class=c1></span>  <span class=n>registerTransformOps</span><span class=o>&lt;</span>
    <span class=c1>// TODO: list the operation classes.
</span><span class=c1></span>  <span class=o>&gt;</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></div><p>The operations themselves can be defined using ODS, exactly in the same way as regular operations in a dialect.</p><div class=highlight><pre class=chroma><code class=language-tablegen data-lang=tablegen><span class=c>// In MyExtension.td
</span><span class=c></span><span class=cp>#ifndef MY_EXTENSION</span>
<span class=cp>#define MY_EXTENSION</span>

<span class=nv>include</span> <span class=s>&#34;mlir/Dialect/Transform/IR/TransformDialect.td&#34;</span>
<span class=nv>include</span> <span class=s>&#34;mlir/Dialect/Transform/IR/TransformInterfaces.td&#34;</span>
<span class=nv>include</span> <span class=s>&#34;mlir/IR/OpBase.td&#34;</span>
<span class=nv>include</span> <span class=s>&#34;mlir/Interfaces/SideEffectInterfaces.td&#34;</span>

<span class=k>def</span> <span class=nv>MyOp</span> <span class=p>:</span> <span class=nv>Op</span><span class=p>&lt;</span><span class=nv>Transform_Dialect</span><span class=p>,</span> <span class=s>&#34;transform.my.op&#34;</span><span class=p>,</span> <span class=p>[</span>
    <span class=c>// TODO: interfaces and traits here.
</span><span class=c></span>   <span class=p>]&gt;</span> <span class=p>{</span>
  <span class=k>let</span> <span class=nv>summary</span> <span class=p>=</span> <span class=s>&#34;my transform op&#34;</span><span class=p>;</span>
  <span class=c>// TODO: define the operation properties.
</span><span class=c></span><span class=p>}</span>

<span class=cp>#endif</span> <span class=c>// MY_EXTENSION
</span></code></pre></div><p>Similarly to dialects, we must use Tablegen to generate the header and implementation of these operations. We can instruct CMake to do it as follows.</p><div class=highlight><pre class=chroma><code class=language-sh data-lang=sh><span class=c1># In CMakeLists.txt next to MyExtension.td.</span>

<span class=c1># Tell Tablegen to use MyExtension.td as input.</span>
set<span class=o>(</span>LLVM_TARGET_DEFINITIONS MyExtension.td<span class=o>)</span>

<span class=c1># Ask Tablegen to generate op declarations and definitions from ODS.</span>
mlir_tablegen<span class=o>(</span>MyExtension.h.inc -gen-op-decls<span class=o>)</span>
mlir_tablegen<span class=o>(</span>MyExtension.cpp.inc -gen-op-defs<span class=o>)</span>

<span class=c1># Add a CMakeTarget we can depend on to ensure the generation happens before the compilation.</span>
add_public_tablegen_target<span class=o>(</span>MyExtensionIncGen<span class=o>)</span>

<span class=c1># Don&#39;t forget to generate the documentation, this will produce a MyExtension.md under </span>
<span class=c1># Dialects.</span>
add_mlir_doc<span class=o>(</span>MyExtension MyExtension Dialects/ -gen-op-doc<span class=o>)</span>
</code></pre></div><div class=highlight><pre class=chroma><code class=language-sh data-lang=sh><span class=c1># In CMakeLists.txt next to MyExtension.cpp</span>
add_mlir_library<span class=o>(</span>
  <span class=c1># Library called MyExtension.</span>
  MyExtension

  <span class=c1># Built from the following source files.</span>
  MyExtension.cpp

  <span class=c1># Make sure ODS declaration and definitions are generated before compiling this.</span>
  DEPENDS
  MyExtensionIncGen

  <span class=c1># Link in the transform dialect, and all generated dialects.</span>
  LINK_LIBS PUBLIC
  MLIRTransformDialect
  MLIRFuncDialect
  MLIRSCFDialect
<span class=o>)</span>
</code></pre></div><p>This will generate two files, <code>MyExtension.h.inc</code> and <code>MyExtension.cpp.inc</code>, that are supposed to be included into the declaration and definition of the transform operations, respectively.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// In MyExtension.h.
</span><span class=c1></span><span class=cp>#include</span> <span class=cpf>&#34;mlir/Dialect/Transform/IR/TransformDialect.h&#34;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&#34;mlir/Dialect/Transform/IR/TransformInterfaces.h&#34;</span><span class=cp>
</span><span class=cp></span>
<span class=cp>#define GET_OP_CLASSES
</span><span class=cp>#include</span> <span class=cpf>&#34;MyExtension.h.inc&#34;</span><span class=cp>
</span></code></pre></div><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// In MyExtension.cpp.
</span><span class=c1></span>
<span class=cp>#define GET_OP_CLASSES
</span><span class=cp>#include</span> <span class=cpf>&#34;MyExtension.cpp.inc&#34;</span><span class=cp>
</span><span class=cp></span>
<span class=c1>// â¦
</span><span class=c1></span><span class=kt>void</span> <span class=n>MyExtension</span><span class=o>::</span><span class=n>init</span><span class=p>()</span> <span class=p>{</span>
  <span class=c1>// â¦
</span><span class=c1></span>
  <span class=c1>// Finally, we register the additional transform operations with the dialect. List all 
</span><span class=c1></span>  <span class=c1>// operations generated from ODS. This call will perform additional checks that the 
</span><span class=c1></span>  <span class=c1>// operations implement the transform and memory effect interfaces required by the 
</span><span class=c1></span>  <span class=c1>// dialect interpreter and assert if they do not.
</span><span class=c1></span>  <span class=n>registerTransformOps</span><span class=o>&lt;</span>
<span class=cp>#define GET_OP_LIST
</span><span class=cp>#include</span> <span class=cpf>&#34;MyExtension.cpp.inc&#34;</span><span class=cp>
</span><span class=cp></span>  <span class=o>&gt;</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></div><h2 id=defining-a-transform-operation>Defining a Transform Operation&nbsp;<a class=headline-hash href=#defining-a-transform-operation>Â¶</a></h2><p>With this setup, we are now ready to define the new transform operation to rewrite the function call. This is identical to defining a regular operation in a dialect. Note that the Transform dialect requires operations to implement the <code>TransformOpInterface</code> as well as <code>MemoryEffectsOpInterface</code> to indicate whether the operands are consumed or only read. Our operation can be defined along the following lines.</p><div class=highlight><pre class=chroma><code class=language-tablegen data-lang=tablegen><span class=c>// In MyExtension.td.
</span><span class=c></span>
<span class=c>// Define the new operation. By convention, prefix its name with the name of the dialect 
</span><span class=c>// extension, &#34;my.&#34;. The full operation name will be further prefixed with &#34;transform.&#34;.
</span><span class=c></span><span class=k>def</span> <span class=nv>ChangeCallTargetOp</span> <span class=p>:</span> <span class=nv>Op</span><span class=p>&lt;</span><span class=nv>Transform_Dialect</span><span class=p>,</span> <span class=s>&#34;my.change_call_target&#34;</span><span class=p>,</span>
    <span class=c>// Indicate that the operation implements the required TransformOpInterface and
</span><span class=c></span>    <span class=c>// MemoryEffectsOpInterface.
</span><span class=c></span>    <span class=p>[</span><span class=nv>DeclareOpInterfaceMethods</span><span class=p>&lt;</span><span class=nv>TransformOpInterface</span><span class=p>&gt;,</span>
     <span class=nv>DeclareOpInterfaceMethods</span><span class=p>&lt;</span><span class=nv>MemoryEffectsOpInterface</span><span class=p>&gt;]&gt;</span> <span class=p>{</span>
  <span class=c>// Provide a brief and a full description. It is recommended that the latter describes 
</span><span class=c></span>  <span class=c>// the effects on the operands and how the operation processes various failure modes.
</span><span class=c></span>  <span class=k>let</span> <span class=nv>summary</span> <span class=p>=</span> <span class=s>&#34;Changes the callee of a call operation to the specified one&#34;</span><span class=p>;</span>
  <span class=k>let</span> <span class=nv>description</span> <span class=p>=</span> <span class=s>[{
</span><span class=s>    For each `func.call` payload operation associated with the handle, changes its 
</span><span class=s>    callee to be the symbol whose name is provided as an attribute to this operation.
</span><span class=s>
</span><span class=s>    Generates a silenceable failure if the operand is associated with payload operations 
</span><span class=s>    that are not `func.call`.
</span><span class=s>    Only reads the operand.
</span><span class=s>  }]</span><span class=p>;</span>

  <span class=c>// The arguments include the handle to the payload operations and the attribute that 
</span><span class=c></span>  <span class=c>// specifies the new callee. The handle must implement TransformHandleTypeInterface.   
</span><span class=c></span>  <span class=c>// We use a string attribute as the symbol may not exist in the transform IR so the 
</span><span class=c></span>  <span class=c>// verification may fail. 
</span><span class=c></span>  <span class=k>let</span> <span class=nv>arguments</span> <span class=p>=</span> <span class=p>(</span><span class=nv>ins</span>
    <span class=nv>TransformHandleTypeInterface</span><span class=p>:</span><span class=nv>$call</span><span class=p>,</span>
    <span class=nv>StrAttr</span><span class=p>:</span><span class=nv>$new_target</span><span class=p>);</span>

  <span class=c>// The results are empty as the transformation does not produce any new payload.
</span><span class=c></span>  <span class=k>let</span> <span class=nv>results</span> <span class=p>=</span> <span class=p>(</span><span class=nv>outs</span><span class=p>);</span>

  <span class=c>// Provide nice syntax.
</span><span class=c></span>  <span class=k>let</span> <span class=nv>assemblyFormat</span> <span class=p>=</span> <span class=s>&#34;$call `,` $new_target attr-dict `:` type($call)&#34;</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>To finalize the definition of the transform operation, we need to implement the interface methods. The <code>TransformOpInterface</code> currently requires only one method â <code>apply</code> â that performs the actual transformation. It is a good practice to limit the body of the method to manipulation of the Transform dialect constructs and have the actual transformation implemented as a standalone function so it can be used from other places in the code.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// In MyExtension.cpp
</span><span class=c1></span>
<span class=c1>// Implementation of our transform dialect operation.
</span><span class=c1>// This operation returns a tri-state result that can be one of:
</span><span class=c1>// - success when the transformation succeeded;
</span><span class=c1>// - definite failure when the transformation failed in such a way that following 
</span><span class=c1>//   transformations are impossible or undesirable, typically it could have left payload 
</span><span class=c1>//   IR in an invalid state; it is expected that a diagnostic is emitted immediately 
</span><span class=c1>//   before returning the definite error;
</span><span class=c1>// - silenceable failure when the transformation failed but following transformations 
</span><span class=c1>//   are still applicable, typically this means a precondition for the transformation is 
</span><span class=c1>//   not satisfied and the payload IR has not been modified.
</span><span class=c1>// The silenceable failure additionally carries a Diagnostic that can be emitted to the 
</span><span class=c1>// user.
</span><span class=c1></span><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DiagnosedSilenceableFailure</span> <span class=n>ChangeCallTargetOp</span><span class=o>::</span><span class=n>apply</span><span class=p>(</span>
    <span class=c1>// The list of payload IR entities that will be associated with the transform IR 
</span><span class=c1></span>    <span class=c1>// values defined by this transform operation. In this case, it can remain empty as 
</span><span class=c1></span>    <span class=c1>// there are no results.
</span><span class=c1></span>    <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>transform</span><span class=o>::</span><span class=n>TransformResults</span> <span class=o>&amp;</span><span class=n>results</span><span class=p>,</span>
    <span class=c1>// The transform application state. This object can be used to query the current 
</span><span class=c1></span>    <span class=c1>// associations between transform IR values and payload IR entities. It can also 
</span><span class=c1></span>    <span class=c1>// carry additional user-defined state.
</span><span class=c1></span>    <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>transform</span><span class=o>::</span><span class=n>TransformState</span> <span class=o>&amp;</span><span class=n>state</span><span class=p>)</span> <span class=p>{</span>

  <span class=c1>// First, we need to obtain the list of payload operations that are associated with 
</span><span class=c1></span>  <span class=c1>// the operand handle.
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>payload</span> <span class=o>=</span> <span class=n>state</span><span class=p>.</span><span class=n>getPayloadOps</span><span class=p>(</span><span class=n>getCall</span><span class=p>());</span>
  
  <span class=c1>// Then, we iterate over the list of operands and call the actual IR-mutating 
</span><span class=c1></span>  <span class=c1>// function. We also check the preconditions here.
</span><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=nl>payloadOp</span> <span class=p>:</span> <span class=n>payload</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>auto</span> <span class=n>call</span> <span class=o>=</span> <span class=n>dyn_cast</span><span class=o>&lt;::</span><span class=n>mlir</span><span class=o>::</span><span class=n>func</span><span class=o>::</span><span class=n>CallOp</span><span class=o>&gt;</span><span class=p>(</span><span class=n>payloadOp</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>call</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>DiagnosedSilenceableFailure</span> <span class=n>diag</span> <span class=o>=</span> <span class=n>emitSilenceableError</span><span class=p>()</span>
          <span class=o>&lt;&lt;</span> <span class=s>&#34;only applies to func.call payloads&#34;</span><span class=p>;</span>
      <span class=n>diag</span><span class=p>.</span><span class=n>attachNote</span><span class=p>(</span><span class=n>payloadOp</span><span class=o>-&gt;</span><span class=n>getLoc</span><span class=p>())</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;offending payload&#34;</span><span class=p>;</span>
      <span class=k>return</span> <span class=n>diag</span><span class=p>;</span>
    <span class=p>}</span>
    
    <span class=n>updateCallee</span><span class=p>(</span><span class=n>call</span><span class=p>,</span> <span class=n>getNewTarget</span><span class=p>());</span>
  <span class=p>}</span>

  <span class=c1>// If everything went well, return success.
</span><span class=c1></span>  <span class=k>return</span> <span class=n>DiagnosedSilenceableFailure</span><span class=o>::</span><span class=n>success</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></div><p>The implementation of the <code>MemoryEffectsOpInterface</code> must specify the effects this operation has on its operands (consumed or readonly) and on the payload IR (mutates or readonly). Transform dialect verifiers will check for side effects being present and assert in debug builds if they are not.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// In MyExtension.cpp
</span><span class=c1></span>
<span class=kt>void</span> <span class=n>ChangeCallTargetOp</span><span class=o>::</span><span class=n>getEffects</span><span class=p>(</span>
    <span class=o>::</span><span class=n>llvm</span><span class=o>::</span><span class=n>SmallVectorImpl</span><span class=o>&lt;::</span><span class=n>mlir</span><span class=o>::</span><span class=n>MemoryEffects</span><span class=o>::</span><span class=n>EffectInstance</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>effects</span><span class=p>)</span> <span class=p>{</span>
  <span class=c1>// Indicate that the `call` handle is only read by this operation because the
</span><span class=c1></span>  <span class=c1>// associated operation is not erased but rather modified in-place, so the
</span><span class=c1></span>  <span class=c1>// reference to it remains valid.
</span><span class=c1></span>  <span class=n>onlyReadsHandle</span><span class=p>(</span><span class=n>getCall</span><span class=p>(),</span> <span class=n>effects</span><span class=p>);</span>

  <span class=c1>// Indicate that the payload is modified by this operation.
</span><span class=c1></span>  <span class=n>modifiesPayload</span><span class=p>(</span><span class=n>effects</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><h2 id=registration-and-usage>Registration and Usage&nbsp;<a class=headline-hash href=#registration-and-usage>Â¶</a></h2><p>This is enough to define transform operations. The only remaining bit is providing the extension registration hook that can be called from the projectâs <code>main</code>.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// In TransformDialect.cpp (don&#39;t forget a declaration in TransformDialect.h);
</span><span class=c1></span>
<span class=kt>void</span> <span class=nf>registerMyExtension</span><span class=p>(</span><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DialectRegistry</span> <span class=o>&amp;</span><span class=n>registry</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>registry</span><span class=p>.</span><span class=n>addExtensions</span><span class=o>&lt;</span><span class=n>MyExtension</span><span class=o>&gt;</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></div><p>After registering the extension, it becomes possible to use our new operation in the transform dialect interpreter. The upstream testing pass can be used as is.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>transform<span class=p>.</span>sequence failures<span class=p>(</span>propagate<span class=p>)</span> <span class=p>{</span>
<span class=nl>^bb0</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>,</span>
     <span class=nv>%arg1</span><span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>op<span class=p>&lt;</span><span class=s>&#34;linalg.matmul&#34;</span><span class=p>&gt;,</span>
     <span class=nv>%arg2</span><span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>op<span class=p>&lt;</span><span class=s>&#34;linalg.elemwise_binary&#34;</span><span class=p>&gt;):</span>
  <span class=c>// Since the %arg2 handle is associated with both elementwise operations,
</span><span class=c></span>  <span class=c>// we need to split it into two handles so we can target only the second
</span><span class=c></span>  <span class=c>// elementwise operation.
</span><span class=c></span>  <span class=nv>%add</span><span class=p>,</span> <span class=nv>%max</span> <span class=p>=</span> transform<span class=p>.</span>split_handle <span class=nv>%arg2</span> <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>op<span class=p>&lt;</span><span class=s>&#34;linalg.elemwise_binary&#34;</span><span class=p>&gt;)</span>
      <span class=p>-&gt;</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>)</span>

  <span class=c>// The actual tiling transformation takes tile sizes as attributes. It produces a
</span><span class=c></span>  <span class=c>// handle to the loop generated during tiling.
</span><span class=c></span>  <span class=nv>%loop</span><span class=p>,</span> <span class=nv>%tiled</span> <span class=p>=</span> transform<span class=p>.</span>structured<span class=p>.</span>tile_to_forall_op <span class=nv>%max</span> tile_sizes <span class=p>[</span><span class=m>8</span><span class=p>,</span> <span class=m>32</span><span class=p>]</span>
      <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>)</span>

  <span class=c>// We can now fuse the other operations into the loop. Here, we fuse
</span><span class=c></span>  <span class=c>// operations one-by-one. This requires the operation that is being fused
</span><span class=c></span>  <span class=c>// to define the value used within the loop, so the order of such fusions
</span><span class=c></span>  <span class=c>// is important. We could also use &#34;transform.merge_handles&#34; to obtain
</span><span class=c></span>  <span class=c>// a single handle to all operations and give it to `fuse_into_containing_op`
</span><span class=c></span>  <span class=c>// that would take care of the ordering in this case.
</span><span class=c></span>  <span class=nv>%add_fused</span> <span class=p>=</span> transform<span class=p>.</span>structured<span class=p>.</span>fuse_into_containing_op <span class=nv>%add</span> into <span class=nv>%loop</span>
      <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>transform<span class=p>.</span>any_op
  <span class=nv>%matmul_fused</span> <span class=p>=</span> transform<span class=p>.</span>structured<span class=p>.</span>fuse_into_containing_op <span class=nv>%arg1</span> into <span class=nv>%loop</span>
      <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>op<span class=p>&lt;</span><span class=s>&#34;linalg.matmul&#34;</span><span class=p>&gt;,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>transform<span class=p>.</span>any_op

  <span class=c>// Tile again to get the desired size. Note that this time this tiles the
</span><span class=c></span>  <span class=c>// &#34;add&#34; operation and fuses matmul into the loop, but doesn&#39;t affect the
</span><span class=c></span>  <span class=c>// &#34;max&#34; operation. This illustrates the precise targeting with the transform
</span><span class=c></span>  <span class=c>// dialect. Otherwise, it is difficult to differentiate &#34;add&#34; and &#34;max&#34;, both
</span><span class=c></span>  <span class=c>// of which having the same kind.
</span><span class=c></span>  <span class=nv>%loop_2</span><span class=p>,</span> <span class=nv>%tiled_2</span> <span class=p>=</span> transform<span class=p>.</span>structured<span class=p>.</span>tile_to_forall_op <span class=nv>%add_fused</span> tile_sizes <span class=p>[</span><span class=m>4</span><span class=p>,</span> <span class=m>4</span><span class=p>]</span>
      <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>)</span>
  <span class=nv>%matmul_fused_2</span> <span class=p>=</span> transform<span class=p>.</span>structured<span class=p>.</span>fuse_into_containing_op <span class=nv>%matmul_fused</span> into <span class=nv>%loop_2</span>
      <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>transform<span class=p>.</span>any_op

  <span class=c>// Since outlining is currently only implemented for region-holding operations
</span><span class=c></span>  <span class=c>// such as loops, use tiling to size 1 to materialize the outer loop that is
</span><span class=c></span>  <span class=c>// going to be outlined.
</span><span class=c></span>  <span class=nv>%outline_target</span><span class=p>,</span> <span class=nv>%_</span> <span class=p>=</span> transform<span class=p>.</span>structured<span class=p>.</span>tile_to_forall_op <span class=nv>%tiled_2</span> tile_sizes <span class=p>[</span><span class=m>1</span><span class=p>]</span>
      <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>)</span>
  transform<span class=p>.</span>structured<span class=p>.</span>fuse_into_containing_op <span class=nv>%matmul_fused_2</span> into <span class=nv>%outline_target</span>
      <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>transform<span class=p>.</span>any_op
  <span class=nv>%func</span><span class=p>,</span> <span class=nv>%call</span> <span class=p>=</span> transform<span class=p>.</span>loop<span class=p>.</span>outline <span class=nv>%outline_target</span> <span class=p>{</span><span class=nl>func_name =</span> <span class=s>&#34;outlined&#34;</span><span class=p>}</span>
      <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>)</span>

  <span class=c>// Rewrite the call target.
</span><span class=c></span>  transform<span class=p>.</span>my<span class=p>.</span>change_call_target <span class=nv>%call</span><span class=p>,</span> <span class=s>&#34;microkernel&#34;</span> <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op

  transform<span class=p>.</span>yield
<span class=p>}</span>
</code></pre></div><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/ title="Chapter 1: Combining Existing Transformations"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Chapter 1: Combining Existing Transformations</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/ title="Chapter 3: More than Simple Transform Operations">Next - Chapter 3: More than Simple Transform Operations <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ArmSMEPasses/></a></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/BufferDeallocationInternals/>Buffer Deallocation - Internals</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/MyExtensionCh2/></a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MyExtensionCh3/></a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLExtensionOps/></a></li><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=https://mlir.llvm.org/docs/Traits/>Traits</a></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on âStructuredâ Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li class=active><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>