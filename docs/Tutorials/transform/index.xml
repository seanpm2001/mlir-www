<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Transform Dialect Tutorial on MLIR</title><link>https://mlir.llvm.org/docs/Tutorials/transform/</link><description>Recent content in Transform Dialect Tutorial on MLIR</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 01 Jan 1970 00:00:00 +0000</lastBuildDate><atom:link href="https://mlir.llvm.org/docs/Tutorials/transform/index.xml" rel="self" type="application/rss+xml"/><item><title>Chapter 0: A Primer on “Structured” Linalg Operations</title><link>https://mlir.llvm.org/docs/Tutorials/transform/Ch0/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Tutorials/transform/Ch0/</guid><description>Before starting the tutorial on the Transform dialect, let us take a brief look at the concept of Structured operations and its implementation in the Linalg dialect. Note that the Transform dialect does not require Structured operations and vice versa. The two co-evolved at the beginning of the Transform dialect, which makes the subset of transformations for Structured operations the most mature and most suitable for the tutorial. If you are already familiar with this concept, skip to Chapter 1.</description></item><item><title>Chapter 1: Combining Existing Transformations</title><link>https://mlir.llvm.org/docs/Tutorials/transform/Ch1/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Tutorials/transform/Ch1/</guid><description>Introduction The Transform dialect allows one to precisely target transformations at specific operations in the IR and to chain them, that is to apply a transformation to operations produced by the previous transformation. To achieve this, transformations are expressed as other operations in the IR. We call these the IR containing these operations transform IR. And we call the IR that is being transformed payload IR.
Transform IR operations operate on values that may be associated with payload IR operations, values or attributes.</description></item><item><title>Chapter 2: Adding a Simple New Transformation Operation</title><link>https://mlir.llvm.org/docs/Tutorials/transform/Ch2/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Tutorials/transform/Ch2/</guid><description>Setting Up to Add New Transformations Before defining a new transform operation, we need to choose where its implementation should be located. While MLIR encourages upstream contributions, it is not always possible or even desirable to modify the main Transform dialect, for example, if the transformation is specific to some out-of-tree dialect that is not itself available upstream.
The Transform dialect uses the dialect extension mechanism to allow additional operations to be injected without modifying the dialect itself.</description></item><item><title>Chapter 3: More than Simple Transform Operations</title><link>https://mlir.llvm.org/docs/Tutorials/transform/Ch3/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Tutorials/transform/Ch3/</guid><description>Type Constraints and ApplyEach Trait A transform operation that applies to each payload operation individually and requires it to be of a specific kind is a repeated pattern. One can use Transform dialect types to specify the preconditions of the type. Specifically, we can change the expected operand type from the wide TransformHandleTypeInterface to the more narrow Transform_ConcreteOp&amp;amp;lt;&amp;quot;func.call&amp;quot;&amp;gt;. Furthermore, we use the TransformEachOpTrait trait to provide the skeleton implementation of the apply method that performs verification, iteration over payloads and result concatenation.</description></item></channel></rss>